/****************************************************************************

    Модуль module_info.c

    Содержит описание функций получения информации о модулях ядра.

    Маткин Илья Александрович               24.12.2015

****************************************************************************/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <psapi.h>
#include <FCNTL.H>
#include <io.h>

#include <winternl.h>

#include "module_info.h"

//----------------------------------------

//
// Возвращает адрес загрузки модуля ядра.
//
DWORD GetDriverImageBase (PCHAR moduleName) {

LPVOID driverBases[1024];
DWORD cbNeeded;
ULONG driverCount;
ULONG i;

    if (EnumDeviceDrivers (driverBases, sizeof(driverBases), &cbNeeded) && cbNeeded < sizeof(driverBases)) { 

        TCHAR buf[1024];

        driverCount = cbNeeded / sizeof(driverBases[0]);
  
        for (i = 0; i < driverCount; ++i) {
            if (GetDeviceDriverBaseName (driverBases[i], buf, sizeof(buf) /sizeof(buf[0]))) {
                if (!strcmp (moduleName, buf)) {
                    //printf ("%d: %x, %s\n", i+1, drivers[i], szDriver);
                    return (DWORD)driverBases[i];
                    }
                }
            }
        }
    else {
        printf ("EnumDeviceDrivers failed; array size needed is %d\n", cbNeeded / sizeof(LPVOID));
        }

    return 0;
}


//--------------------


//
// Возвращает имя загруженного ядра.
//
BOOL GetKernelName (PCHAR kernelName) {

LPVOID driverBases[1024];
DWORD cbNeeded;

    if (EnumDeviceDrivers (driverBases, sizeof(driverBases), &cbNeeded) && cbNeeded < sizeof(driverBases)) { 

        // ядро будет первым в списке загруженных модулей
        if (GetDeviceDriverBaseName (driverBases[0], kernelName, 1024)) {
            return TRUE;
            }
        else {
            return FALSE;
            }
        }
    else {
        printf ("EnumDeviceDrivers failed; array size needed is %d\n", cbNeeded / sizeof(LPVOID));
        }

    return FALSE;
}


//--------------------


//
// Возвращает адрес экспортируемой функции в загруженном ядре.
//
DWORD GetKernelProcAddress (PCHAR module, LPCSTR procName) {

    HMODULE moduleHandle;
    FARPROC procPointer;

    if ((moduleHandle = LoadLibraryEx (module, NULL, DONT_RESOLVE_DLL_REFERENCES)) == NULL)
        return 0;

    if ((procPointer = GetProcAddress (moduleHandle, procName)) == NULL) {
        FreeLibrary (moduleHandle);
        return 0;
        }

    FreeLibrary (moduleHandle);
    
    return ((DWORD)procPointer - (DWORD)moduleHandle + GetDriverImageBase (module));
}


//--------------------
